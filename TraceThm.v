From Coq Require Import
     Morphisms
     Setoid
     RelationClasses
     Arith
     Lia
     List.

From ExtLib Require Import
     Monad
     Traversable
     Data.List.

From ITree Require Import
     ITree
     ITreeFacts
     Traces.

Import ListNotations.
Import ITreeNotations.
Import MonadNotation.
Import SumNotations.
Open Scope monad_scope.

Section Proper.
  Local Open Scope signature_scope.
  Global Instance proper_is_trace {E R} : Proper ((@eutt E R R eq) ==> eq ==> iff) is_trace.
  Proof.
    intros t t' Ht tr tr' Htr. subst tr'.
    apply trace_eq_iff_eutt in Ht.
    unfold trace_eq in Ht.
    intuition.
  Qed.
End Proper.

(* There are only three effects. Read current state, read the action generated by agent with current state, update current state. Each step an agent goes in an environment will cause these three effects. *)

Inductive stateE {StateT : Type}: Type -> Type :=
| GetState: stateE StateT
| PutState : StateT -> stateE unit.

Inductive actionE {ActionT : Type}: Type -> Type :=
| AgentAction : actionE ActionT.

Definition rlE {StateT ActionT: Type} := (@stateE StateT) +' (@actionE ActionT).

(* A trace of a reinforcement environment looks like "{s <- GetState ;; a <- AgentAction ;; tt <- PutState s'}*": "s" represents the current state, "a" represents the action generated by the agent, "s'" indicates the next state, which is the output of an environment. A RL trace has to follow the consistency requirement: the adjacent "s'" and "s" should be equal. i.e. in "s1 <- GetState ;; a1 <- AgentAction ;; tt <- PutState s1' ;; a2 <- GetState ;; a2 <- AgentAction ;; tt <- PutState s2'...", "s1' = s2".  *)

Notation "[ e , a ] t" := (TEventResponse e a t) (at level 80, right associativity).
Notation "[< e >]" := (TEventEnd e) (at level 80, right associativity).
Open Scope sum_scope.

Inductive state_trace {StateT ActionT: Type} {E: Type -> Type}: @trace ((@stateE StateT) +' E) unit -> Prop :=
| Str0 : forall {X} (e: ((@stateE StateT) +' E) X), state_trace ([< e >])
| Str1 : forall {X} (e1 e2: ((@stateE StateT) +' E) X) r, state_trace ([e1, r] [< e2 >])
| Str2 : forall s1 s2 tr, state_trace ([ (GetState|), s2] tr) -> s1 = s2 ->
                          state_trace ([ (GetState|), s1] [ (GetState|), s2] tr)
| Str3 : forall s1 s2 tr, state_trace ([ (GetState|), s2] tr) -> s1 = s2 ->
                          state_trace ([ (PutState s1|), tt] [ (GetState|), s2] tr)
| Str4 : forall {X} s (e: E X) r tr, state_trace ([ (GetState|), s] tr) ->
                                     state_trace ([ (|e), r] [ (GetState|), s] tr)
| Str5 : forall s1 s2 tr, state_trace ([ (PutState s2|), tt] tr) ->
                          state_trace ([ (GetState|), s1] [ (PutState s2|), tt] tr)
| Str6 : forall s1 s2 tr, state_trace ([ (PutState s2|), tt] tr) ->
                          state_trace ([ (PutState s1|), tt] [ (PutState s2|), tt] tr)
| Str7 : forall {X} s (e: E X) r tr, state_trace ([ (PutState s|), tt] tr) ->
                                     state_trace ([ (|e), r] [ (PutState s|), tt] tr)
| Str8 : forall {X} (e1: ((@stateE StateT) +' E) X) (e2: E X) r1 r2 tr,
    state_trace ([ e1, r1] tr) ->
    state_trace ([ e1, r1] [ (|e2), r2] tr).

Hint Constructors state_trace.

(* Definition StepRecord {StateT ActionT : Type} : Type := StateT * ActionT * StateT. *)

(* Definition step2trace {StateT ActionT : Type} (x : @StepRecord StateT ActionT) : @trace rlE unit := *)
(*   match x with *)
(*     (s, a, s') => [(GetState|), s] [(|AgentAction), a] [< (PutState s'|) >] *)
(*   end. *)

(* Definition append_step2trace {StateT ActionT : Type} (x : @StepRecord StateT ActionT) (tr: @trace rlE unit) : @trace rlE unit :=  *)
(*   match x with *)
(*     (s, a, s') => [(GetState|), s] [(|AgentAction), a] [(PutState s'|), tt] tr *)
(*   end. *)

(* Definition step_adjacent {StateT ActionT : Type} (x1 x2: @StepRecord StateT ActionT) : Prop := *)
(*   match x1, x2 with *)
(*     (s1, a1, s1'), (s2, a2, s2') => s1' = s2 *)
(*   end. *)

(* (* inversion lemma for adjacent *) *)

(* Lemma inv_step_adjacent {StateT ActionT : Type} : forall (s1 s1' s2 s2': StateT) (a1 a2 : ActionT), step_adjacent (s1, a1, s1') (s2, a2, s2') <-> s1' = s2. *)
(* Proof. *)
(*   split; intros. *)
(*   - inversion H. reflexivity. *)
(*   - rewrite H. constructor. *)
(* Qed. *)

(* inj_pair2_dec *)

Ltac inj_dep_pair :=
  match goal with
  | [H : existT _ _ _ = existT _ _ _ |- _] => (apply (Eqdep.EqdepTheory.inj_pair2 Type) in H; subst)
  end.

Ltac clear_id :=
  match goal with
  | [H : ?a = ?a |- _] => clear H
  end.

Ltac inj_dep_pair_all := repeat (try inj_dep_pair; idtac).
Ltac auto_is_trace_H H := unfold observe in H; cbn in H.
Ltac inv_is_trace H := auto_is_trace_H H; inversion H; try inj_dep_pair_all; try clear_id; try clear H.

Ltac inv_dep H := inversion H; try inj_dep_pair_all; try clear_id; try clear H.

(* inversion lemma for is_trace *)

Lemma inv_trigger : forall (E : Type -> Type) (R T: Type), forall (k : T -> _) e1 e2 s (tr: @trace E R),
    is_trace (ITree.bind (ITree.trigger e1) k) ([e2, s] tr) <-> e1 = e2 /\ is_trace (k s) tr.
Proof.
  split; intros.
  - repeat setoid_rewrite bind_trigger in H. inv_is_trace H. auto.
  - unfold is_trace, observe. cbn. destruct H. subst. constructor. auto.
Qed.

Lemma inv_trigger_2 {E : Type -> Type} {R T: Type}: forall (k : T -> _) (e1 e2: E T),
    @is_trace E R (ITree.bind (ITree.trigger e1) k) ([<e2>]) <-> e1 = e2.
Proof.
  split; intros.
  - repeat setoid_rewrite bind_trigger in H. inv_is_trace H. auto.
  - unfold is_trace, observe. cbn. destruct H. subst. constructor.
Qed.

Lemma inv_trigger_Ret {E : Type -> Type} {R T: Type}: forall (k : T -> _) (e1 e2: E T) t,
    @is_trace E R (ITree.bind (ITree.trigger e1) k) (TRet t) -> False.
Proof.
  intros.
  - repeat setoid_rewrite bind_trigger in H. inv_is_trace H.
Qed.

Hint Resolve inv_trigger.
Hint Rewrite inv_trigger.
Hint Resolve inv_trigger_2.

(* Environment *)

(* The rl environment to has to gerantee the following rule: *)
(*   1) read a state, i.e. "s". *)
(*   2) read a action from agent, i.e. "a". *)
(*   3) run a pure function "f: StateT -> ActionT -> StateT" on the read state and action, i.e. "s' <- f s a". *)
(*   4) rewrite the new state, i.e. "s'". *)
(*   5) go back to step 1. *)

(* be notation *)

Definition env_body {StateT ActionT : Type} (f: StateT -> ActionT -> StateT) : unit -> itree (callE unit unit +' rlE) unit :=
  (fun _ : unit =>
            state <- ITree.trigger (|GetState|);;
            action <- ITree.trigger (||AgentAction);;
            ITree.trigger (|PutState (f state action)|);; call tt).

Definition env_generator {StateT ActionT : Type} (f: StateT -> ActionT -> StateT) : itree (@rlE StateT ActionT) unit :=
  rec (env_body f) tt.

Inductive step_trace {StateT ActionT : Type} : @trace (@rlE StateT ActionT) unit -> Prop :=
| step_trace00 : step_trace TEnd
| step_trace01 : step_trace ([<(GetState|)>])
| step_trace10 : forall s, step_trace ([(GetState|), s] TEnd)
| step_trace11 : forall s, step_trace ([(GetState|), s] [<(| AgentAction)>])
| step_trace20 : forall s a, step_trace ([(GetState|), s] [(|AgentAction), a] TEnd)
| step_trace21 : forall s a s',
    step_trace ([(GetState|), s] [(|AgentAction), a] [<(PutState s'|)>])
| step_trace3: forall s a s' tr t,
    step_trace tr ->
    t = tt ->
    step_trace ([(GetState|), s] [(|AgentAction), a] [(PutState s'|), t] tr).

Hint Constructors step_trace.

Ltac is_trace_autoinv :=
  repeat match goal with
         | H : is_trace _ (TEventEnd ?a) |- _ => cbn in H; try (rewrite inv_trigger_2 in H)
         | H : is_trace _ _ |- _ => cbn in H; try (rewrite inv_trigger in H)
         | H : _ /\ _ |- _ => destruct H
         end.

Ltac is_trace_auto :=
  repeat match goal with
         | H : _ |- is_trace _ (TEventEnd ?a) => cbn; try (rewrite inv_trigger_2)
         | H : _ |- is_trace _ _ => cbn; try (rewrite inv_trigger)
         | H : _ |- _ /\ _ => split; subst; auto
         end.

Lemma unfold_one_env {StateT ActionT : Type} : forall (bodyf: StateT -> ActionT -> StateT),
    (rec (env_body bodyf) tt) â‰ˆ (r <- ITree.trigger (GetState|);;
                                   r0 <- ITree.trigger (|AgentAction);;
                                   ITree.trigger (PutState (bodyf r r0)|);;
                                   (rec (env_body bodyf) tt)).
Proof.
  intros.
  setoid_rewrite rec_as_interp at 1.
  unfold env_body at 2.
  repeat setoid_rewrite interp_bind.
  repeat setoid_rewrite interp_trigger.
  cbn. reflexivity.
Qed.

Lemma env_trace_is_step_trace {StateT ActionT : Type} : forall tr bodyf, is_trace (env_generator bodyf) tr <-> @step_trace StateT ActionT tr.
Proof.
  unfold env_generator. intros.
  induction tr; auto.
  - split; intros; auto. inv_is_trace H. unfold is_trace. constructor.
  - split; intros; auto. rewrite unfold_one_env in H.
    repeat setoid_rewrite bind_trigger in H. inv_is_trace H. inversion H.
  - split; intros; auto. rewrite unfold_one_env in H.
    repeat setoid_rewrite bind_trigger in H. inv_is_trace H. auto.
    inv_is_trace H. rewrite unfold_one_env. unfold is_trace. cbn. constructor.
  - destruct IHtr. split; intros; auto.
    rewrite unfold_one_env in H1. repeat setoid_rewrite bind_trigger in H1. inv_is_trace H1.
    induction tr; try inv_is_trace H3; auto.
    induction tr; try inv_is_trace H2; auto.
    apply step_trace3.
    + cbn in H3. inversion H3.
    + 
    induction tr; try inv_is_trace H0; auto.
    apply step_trace3.
Qed.

(* step is one step of an rl environment recursion. *)

Definition step_generator {StateT ActionT : Type} (f: StateT -> ActionT -> StateT) : itree (@rlE StateT ActionT) unit :=
  state <- ITree.trigger (GetState|) ;; (* read current state *)
        action <- ITree.trigger (|AgentAction) ;; (* read action from agent *)
        t <- ITree.trigger (PutState (f state action)|) ;; (* write new state *)
        Ret t.

Lemma is_trace_bodyf {StateT ActionT : Type} : forall (s s': StateT) (a: ActionT) bodyf,
    is_trace (step_generator bodyf) (step2trace (s, a, s')) <->
    bodyf s a = s'.
Proof.
  unfold step_generator; split; intros.
  - is_trace_autoinv.
    inversion H1. auto.
  - is_trace_auto. auto.
Qed.

Lemma is_trace_rec_to_step {StateT ActionT : Type} : forall (s s': StateT) (a: ActionT) bodyf,
    is_trace (env_generator bodyf) (step2trace (s, a, s')) <->
    is_trace (step_generator bodyf) (step2trace (s, a, s')).
Proof.
  split; intros.
  - setoid_rewrite rec_as_interp in H.
    match goal with
    | H: context [recursive ?b] |- _ => remember b as body in H
    end.
    repeat setoid_rewrite interp_bind in H.
    repeat setoid_rewrite interp_trigger in H.
    is_trace_autoinv.
    inversion H1.
    rewrite is_trace_bodyf. auto.
  - rewrite is_trace_bodyf in H.
    unfold env_generator. cbn.
    setoid_rewrite rec_as_interp.
    match goal with
    | H: _ |- context [recursive ?b] => remember b as body in H
    end.
    repeat setoid_rewrite interp_bind.
    repeat setoid_rewrite interp_trigger.
    is_trace_auto. auto.
Qed.

Lemma is_trace_rl_split {StateT ActionT: Type}: forall s a s' (tr: @trace (@rlE StateT ActionT) unit) bodyf,
    is_trace (env_generator bodyf) (append_step2trace (s, a, s') tr) ->
    (is_trace (env_generator bodyf) tr) /\
    is_trace (env_generator bodyf) (step2trace (s, a, s')).
Proof.
  intros. cbn in H. unfold env_generator in H.
  setoid_rewrite rec_as_interp in H.
  match goal with
  | H: context [recursive ?b] |- _ => remember b as body in H
  end.
  repeat setoid_rewrite interp_bind in H.
  repeat setoid_rewrite interp_trigger in H.
  is_trace_autoinv.
  split.
  - unfold env_generator.
    unfold rec_fix.
    rewrite <- Heqbody.
    auto.
  - rewrite is_trace_rec_to_step.
    rewrite is_trace_bodyf.
    inversion H1.
    auto.
Qed.

(* The first input state of a trace satisfy the property phi. *)

Inductive trace_init {StateT ActionT: Type} : (StateT -> Prop) -> @trace rlE unit -> Prop :=
| nil_trace_init :
    forall (s s': StateT) (a: ActionT) (phi: StateT -> Prop),
      phi s -> trace_init phi (step2trace (s, a, s'))
| cons_trace_init :
    forall (s s': StateT) (a: ActionT) (phi: StateT -> Prop) tr,
      phi s -> trace_init phi (append_step2trace (s, a, s') tr).

(* The last output state of a trace satisfy the property phi. *)

Inductive trace_end {StateT ActionT: Type} : (StateT -> Prop) -> @trace rlE unit -> Prop :=
| nil_trace_end :
    forall (s s': StateT) (a: ActionT) (phi: StateT -> Prop),
      phi s' -> trace_end phi (step2trace (s, a, s'))
| cons_trace_end :
    forall (s s': StateT) (a: ActionT) (phi: StateT -> Prop) tr,
      trace_end phi tr -> trace_end phi (append_step2trace (s, a, s') tr).

Hint Constructors trace_init.
Hint Constructors trace_end.

Lemma inv_nil_trace_init {StateT ActionT: Type} : forall phi s a s',
    @trace_init StateT ActionT phi (step2trace (s, a, s')) <-> phi s.
Proof.
  split; intros; (try inv_dep H; auto).
Qed.

Lemma inv_nil_trace_end {StateT ActionT: Type} : forall phi s a s',
    @trace_end StateT ActionT phi (step2trace (s, a, s')) <-> phi s'.
Proof.
  split; intros; (try inv_dep H; auto).
Qed.

Lemma inv_cons_trace_init {StateT ActionT: Type} : forall phi s a s' tr,
    @trace_init StateT ActionT phi (append_step2trace (s, a, s') tr) <->
    phi s.
Proof.
  split; intros; (try inv_dep H; auto).
Qed.

Lemma inv_cons_trace_end {StateT ActionT: Type} : forall phi s a s' tr,
    @trace_end StateT ActionT phi (append_step2trace (s, a, s') tr) <->
    trace_end phi tr.
Proof.
  split; intros; (try inv_dep H; auto).
Qed.
