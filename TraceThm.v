From Coq Require Import
     Morphisms
     Setoid
     RelationClasses
     Arith
     Lia
     List.

From ExtLib Require Import
     Monad
     Traversable
     Data.List.

From ITree Require Import
     ITree
     ITreeFacts
     Traces.

Import ListNotations.
Import ITreeNotations.
Import MonadNotation.
Open Scope monad_scope.

Section Proper.
  Local Open Scope signature_scope.
  Global Instance proper_is_trace {E R} : Proper ((@eutt E R R eq) ==> eq ==> iff) is_trace.
  Proof.
    intros t t' Ht tr tr' Htr. subst tr'.
    apply trace_eq_iff_eutt in Ht.
    unfold trace_eq in Ht.
    intuition.
  Qed.
End Proper.

(* There are only three effects. Read current state, read the action generated by agent with current state, update current state. Each step an agent goes in an environment will cause these three effects. *)

Inductive rlE {StateT ActionT : Type}: Type -> Type :=
| InputA : rlE ActionT
| InputS: rlE StateT
| OutputS : StateT -> rlE unit.

(* A trace of a reinforcement environment looks like "{s <- InputS ;; a <- InputA ;; tt <- OutputS s'}*": "s" represents the current state, "a" represents the action generated by the agent, "s'" indicates the next state, which is the output of an environment. A RL trace has to follow the consistency requirement: the adjacent "s'" and "s" should be equal. i.e. in "s1 <- InputS ;; a1 <- InputA ;; tt <- OutputS s1' ;; a2 <- InputS ;; a2 <- InputA ;; tt <- OutputS s2'...", "s1' = s2".  *)

Notation "[ e , a ] t" := (TEventResponse e a t) (at level 80, right associativity).
Notation "[< e >]" := (TEventEnd e) (at level 80, right associativity).

Definition StepRecord {StateT ActionT : Type} : Type := StateT * ActionT * StateT.

Definition nil_rl_trace {StateT ActionT : Type} (x : @StepRecord StateT ActionT) : @trace rlE unit :=
  match x with
    (s, a, s') => [InputS, s] [InputA, a] [< OutputS s'>]
  end.

Definition cons_rl_trace {StateT ActionT : Type} (x : @StepRecord StateT ActionT) (tr: @trace rlE unit) : @trace rlE unit := 
  match x with
    (s, a, s') => [InputS, s] [InputA, a] [OutputS s', tt] tr
  end.

Definition step_adjacent {StateT ActionT : Type} (x1 x2: @StepRecord StateT ActionT) : Prop :=
  match x1, x2 with
    (s1, a1, s1'), (s2, a2, s2') => s1' = s2
  end.

(* inversion lemma for adjacent *)

Lemma inv_step_adjacent {StateT ActionT : Type} : forall (s1 s1' s2 s2': StateT) (a1 a2 : ActionT), step_adjacent (s1, a1, s1') (s2, a2, s2') <-> s1' = s2.
Proof.
  split; intros.
  - inversion H. reflexivity.
  - rewrite H. constructor.
Qed.

Inductive is_rltrace {StateT ActionT : Type} : @trace (@rlE StateT ActionT) unit -> Prop :=
| ret_is_rltrace : forall x, is_rltrace (nil_rl_trace x)
| bind_ret_is_rltrace: forall x1 x2,
    step_adjacent x1 x2 ->
    is_rltrace (cons_rl_trace x1 (nil_rl_trace x2))
| bind_bind_is_rltrace: forall x1 x2 tr,
    step_adjacent x1 x2 ->
    is_rltrace (cons_rl_trace x2 tr) ->
    is_rltrace (cons_rl_trace x1 (cons_rl_trace x2 tr)).

Ltac inj_dep_pair :=
  match goal with
  | [H : existT _ _ _ = existT _ _ _ |- _] => (apply (Eqdep.EqdepTheory.inj_pair2 Type) in H; subst)
  end.

Ltac clear_id :=
  match goal with
  | [H : ?a = ?a |- _] => clear H
  end.

Ltac inj_dep_pair_all := repeat (try inj_dep_pair; idtac).
Ltac auto_is_trace_H H := unfold observe in H; cbn in H.
Ltac inv_is_trace H := auto_is_trace_H H; inversion H; try inj_dep_pair_all; try clear_id; try clear H.

Ltac inv_dep H := inversion H; try inj_dep_pair_all; try clear_id; try clear H.

(* inversion lemma for is_trace *)

Lemma inv_trigger_input_s {StateT ActionT : Type}: forall k s (tr: @trace (@rlE StateT ActionT) unit),
    is_trace (ITree.bind (ITree.trigger InputS) k) ([InputS, s] tr) <-> is_trace (k s) tr.
Proof.
  split; intros.
  - repeat setoid_rewrite bind_trigger in H. inv_is_trace H. auto.
  - unfold is_trace, observe. cbn. constructor. auto.
Qed.

Lemma inv_trigger_input_a {StateT ActionT : Type} : forall k a (tr: @trace (@rlE StateT ActionT) unit),
    is_trace (ITree.bind (ITree.trigger InputA) k) ([InputA, a] tr) <-> is_trace (k a) tr.
Proof.
  split; intros.
  - repeat setoid_rewrite bind_trigger in H. inv_is_trace H. auto.
  - unfold is_trace, observe. cbn. constructor. auto.
Qed.

Lemma inv_trigger_output_s {StateT ActionT : Type} : forall k s s' (tr: @trace (@rlE StateT ActionT) unit),
    is_trace (ITree.trigger (OutputS s);; k tt) ([OutputS s', tt] tr) <-> s = s' /\ is_trace (k tt) tr.
Proof.
  split; intros.
  - repeat setoid_rewrite bind_trigger in H. inv_is_trace H. split; auto. inversion H2; auto.
  - destruct H. unfold is_trace, observe. cbn. rewrite H. constructor. auto.
Qed.

Lemma inv_trigger_output_s_2 {StateT ActionT : Type} : forall (t : itree (@rlE StateT ActionT) unit) s s',
    is_trace (ITree.trigger (OutputS s);; t) ([<OutputS s'>]) <-> s = s'.
Proof.
  split; intros.
  - repeat setoid_rewrite bind_trigger in H. inv_is_trace H. inversion H2; auto.
  - destruct H. unfold is_trace, observe. cbn. constructor.
Qed.

(* Environment *)

(* The rl environment to has to gerantee the following rule: *)
(*   1) read a state, i.e. "s". *)
(*   2) read a action from agent, i.e. "a". *)
(*   3) run a pure function "f: StateT -> ActionT -> StateT" on the read state and action, i.e. "s' <- f s a". *)
(*   4) rewrite the new state, i.e. "s'". *)
(*   5) go back to step 1. *)

Definition trigger_inr1 {D E : Type -> Type} : E ~> itree (D +' E)
  := fun _ e => ITree.trigger (inr1 e).
Arguments trigger_inr1 {D E} [T].

Definition env_generator {StateT ActionT : Type} (f: StateT -> ActionT -> StateT) : itree (@rlE StateT ActionT) unit :=
  (rec-fix env_ _ :=
     state <- trigger_inr1 InputS ;; (* read current state *)
           action <- trigger_inr1 InputA ;; (* read action from agent *)
           trigger_inr1 (OutputS (f state action)) ;; (* write new state *)
           env_ tt
  ) tt.

(* step is one step of an rl environment recursion. *)

Definition step_generator {StateT ActionT : Type} (f: StateT -> ActionT -> StateT) : itree (@rlE StateT ActionT) unit :=
  state <- ITree.trigger InputS ;; (* read current state *)
        action <- ITree.trigger InputA ;; (* read action from agent *)
        ITree.trigger (OutputS (f state action)) ;; (* write new state *)
        Ret tt.

Lemma is_trace_bodyf {StateT ActionT : Type} : forall (s s': StateT) (a: ActionT) bodyf,
    is_trace (step_generator bodyf) (nil_rl_trace (s, a, s')) <->
    bodyf s a = s'.
Proof.
  split; intros.
  - unfold step_generator in H. cbn in H.
    rewrite inv_trigger_input_s in H.
    rewrite inv_trigger_input_a in H.
    rewrite inv_trigger_output_s_2 in H.
    auto.
  - unfold step_generator. cbn.
    rewrite inv_trigger_input_s.
    rewrite inv_trigger_input_a.
    rewrite inv_trigger_output_s_2.
    auto.
Qed.

Lemma is_trace_rec_to_step {StateT ActionT : Type} : forall (s s': StateT) (a: ActionT) bodyf,
    is_trace (env_generator bodyf) (nil_rl_trace (s, a, s')) <->
    is_trace (step_generator bodyf) (nil_rl_trace (s, a, s')).
Proof.
  split; intros.
  - setoid_rewrite rec_as_interp in H.
    match goal with
    | H: context [recursive ?b] |- _ => remember b as body in H
    end.
    repeat setoid_rewrite interp_bind in H.
    repeat setoid_rewrite interp_trigger in H.
    cbn in H.
    rewrite inv_trigger_input_s in H.
    rewrite inv_trigger_input_a in H.
    rewrite inv_trigger_output_s_2 in H.
    rewrite is_trace_bodyf. auto.
  - rewrite is_trace_bodyf in H.
    unfold env_generator. cbn.
    setoid_rewrite rec_as_interp.
    match goal with
    | H: _ |- context [recursive ?b] => remember b as body in H
    end.
    repeat setoid_rewrite interp_bind.
    repeat setoid_rewrite interp_trigger.
    cbn.
    rewrite inv_trigger_input_s.
    rewrite inv_trigger_input_a.
    rewrite inv_trigger_output_s_2.
    auto.
Qed.

Lemma is_trace_rl_split {StateT ActionT: Type}: forall s a s' (tr: @trace (@rlE StateT ActionT) unit) bodyf,
    is_trace (env_generator bodyf) (cons_rl_trace (s, a, s') tr) ->
    (is_trace (env_generator bodyf) tr) /\
    is_trace (env_generator bodyf) (nil_rl_trace (s, a, s')).
Proof.
  intros. cbn in H. unfold env_generator in H.
  setoid_rewrite rec_as_interp in H.
  match goal with
  | H: context [recursive ?b] |- _ => remember b as body in H
  end.
  repeat setoid_rewrite interp_bind in H.
  repeat setoid_rewrite interp_trigger in H.
  cbn in H.
  rewrite inv_trigger_input_s in H.
  rewrite inv_trigger_input_a in H.
  rewrite inv_trigger_output_s in H.
  destruct H. split.
  - unfold env_generator.
    unfold rec_fix.
    rewrite <- Heqbody.
    auto.
  - rewrite is_trace_rec_to_step.
    rewrite is_trace_bodyf.
    auto.
Qed.

(* The first input state of a trace satisfy the property phi. *)

Inductive trace_init {StateT ActionT: Type} : (StateT -> Prop) -> @trace rlE unit -> Prop :=
| nil_trace_init :
    forall (s s': StateT) (a: ActionT) (phi: StateT -> Prop),
      phi s -> trace_init phi (nil_rl_trace (s, a, s'))
| cons_trace_init :
    forall (s s': StateT) (a: ActionT) (phi: StateT -> Prop) tr,
      phi s -> trace_init phi (cons_rl_trace (s, a, s') tr).

(* The last output state of a trace satisfy the property phi. *)

Inductive trace_end {StateT ActionT: Type} : (StateT -> Prop) -> @trace rlE unit -> Prop :=
| nil_trace_end :
    forall (s s': StateT) (a: ActionT) (phi: StateT -> Prop),
      phi s' -> trace_end phi (nil_rl_trace (s, a, s'))
| cons_trace_end :
    forall (s s': StateT) (a: ActionT) (phi: StateT -> Prop) tr,
      trace_end phi tr -> trace_end phi (cons_rl_trace (s, a, s') tr).

Hint Constructors trace_init.
Hint Constructors trace_end.

Lemma inv_nil_trace_init {StateT ActionT: Type} : forall phi s a s',
    @trace_init StateT ActionT phi (nil_rl_trace (s, a, s')) <-> phi s.
Proof.
  split; intros; (try inv_dep H; auto).
Qed.

Lemma inv_nil_trace_end {StateT ActionT: Type} : forall phi s a s',
    @trace_end StateT ActionT phi (nil_rl_trace (s, a, s')) <-> phi s'.
Proof.
  split; intros; (try inv_dep H; auto).
Qed.

Lemma inv_cons_trace_init {StateT ActionT: Type} : forall phi s a s' tr,
    @trace_init StateT ActionT phi (cons_rl_trace (s, a, s') tr) <->
    phi s.
Proof.
  split; intros; (try inv_dep H; auto).
Qed.

Lemma inv_cons_trace_end {StateT ActionT: Type} : forall phi s a s' tr,
    @trace_end StateT ActionT phi (cons_rl_trace (s, a, s') tr) <->
    trace_end phi tr.
Proof.
  split; intros; (try inv_dep H; auto).
Qed.
