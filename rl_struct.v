From Coq Require Import
     Arith
     Lia
     List.

From ExtLib Require Import
     Monad
     Traversable
     Data.List.

From ITree Require Import
     Simple
     Traces.

Import ListNotations.
Import ITreeNotations.
Import MonadNotation.
Open Scope monad_scope.

(* * Idea * *)
(* An environment is an transition system over state space and action space. An deterministic environment has type "State * Action -> State" and an agent policy has type "State -> Action". Now represent an environment as an itree and agent policy as effect. *)

(* * Example * *)
(* One-demension road with cliff. State space has type "nat" and there is a cliff at position "4". Action space is "{Left, Right}". If the car reach position "4" it will crash. A safe environment should not let this happen while any decision the agent makes. *)

Definition StateT := nat.

Inductive ActionT : Type :=
| Left
| Right.

(* There are only three effects. Read current state, read the action generated by agent with current state, update current state. Each step an agent goes in an environment will cause these three effects. *)

Inductive rlE : Type -> Type :=
| InputA : rlE ActionT
| InputS: rlE StateT
| OutputS : StateT -> rlE unit.

(* An enviornment has type "itree rlE unit", which says it can cause all effects in rlE and return nothing(the only output of an environment is exported by "OutputS"). It should first read current state and the action maked by agent, then write a new state. *)

Definition trigger_inr1 {D E : Type -> Type} : E ~> itree (D +' E)
  := fun _ e => ITree.trigger (inr1 e).
Arguments trigger_inr1 {D E} [T].

Definition unsafe_env : itree rlE unit :=
  (rec-fix env_ _ :=
     state <- trigger_inr1 InputS ;; (* read current state *)
           action <- ITree.trigger (inr1 InputA) ;; (* read action from agent *)
           match (state, action) with
           | (0, Left) => ITree.trigger (inr1 (OutputS 0)) ;; env_ tt
           | (S s, Left) => ITree.trigger (inr1 (OutputS s)) ;; env_ tt
           | (s, Right) => ITree.trigger (inr1 (OutputS (S s))) ;; env_ tt
           end
  ) tt.

Definition safe_env : itree rlE unit :=
  (rec-fix env_ _ :=
     state <- trigger_inr1 InputS ;; (* read current state *)
           action <- ITree.trigger (inr1 InputA) ;; (* read action from agent *)
           match (state, action) with
           | (0, Left) => ITree.trigger (inr1 (OutputS 0)) ;; env_ tt
           | (S s, Left) => ITree.trigger (inr1 (OutputS s)) ;; env_ tt
           (* a safe environment adds a barrier at position 3. *)
           | (3, Right) => ITree.trigger (inr1 (OutputS 3)) ;; env_ tt
           | (s, Right) => ITree.trigger (inr1 (OutputS (S s))) ;; env_ tt
           end
  ) tt.

(* A trace of a reinforcement environment looks like "{s <- InputS ;; a <- InputA ;; tt <- OutputS s'}*": "s" represents the current state, "a" represents the action generated by the agent, "s'" indicates the next state, which is the output of an environment. A RL trace has to follow the consistency requirement: the adjacent "s'" and "s" should be equal. i.e. in "s1 <- InputS ;; a1 <- InputA ;; tt <- OutputS s1' ;; a2 <- InputS ;; a2 <- InputA ;; tt <- OutputS s2'...", "s1' = s2".  *)

Notation "[ e , a ] t" := (TEventResponse e a t) (at level 80, right associativity).
Notation "[< e >]" := (TEventEnd e) (at level 80, right associativity).

Definition StepRecord : Type := StateT * ActionT * StateT.

Definition ret_rl_trace (x : StepRecord) : @trace rlE unit :=
  match x with
    (s, a, s') => [InputS, s] [InputA, a] [< OutputS s'>]
  end.
Definition bind_rl_trace (x : StepRecord) (tr: @trace rlE unit) : @trace rlE unit := 
  match x with
    (s, a, s') => [InputS, s] [InputA, a] [OutputS s', tt] tr
  end.

Definition step_adjacent (x1 x2: StepRecord) : Prop :=
  match x1, x2 with
    (s1, a1, s1'), (s2, a2, s2') => s1' = s2
  end.

Inductive is_rltrace : @trace rlE unit -> Prop :=
| ret_is_rltrace : forall x, is_rltrace (ret_rl_trace x)
| bind_ret_is_rltrace: forall x1 x2,
    step_adjacent x1 x2 ->
    is_rltrace (bind_rl_trace x1 (ret_rl_trace x2))
| bind_bind_is_rltrace: forall x1 x2 tr,
    step_adjacent x1 x2 ->
    is_rltrace (bind_rl_trace x2 tr) ->
    is_rltrace (bind_rl_trace x1 (bind_rl_trace x2 tr)).

(* An inductive invariant of an environment says: within one step "(s,a,s')", if "s" <= 3, forall "a", "s'" <=3. *)

Print Eqdep.EqdepTheory.inj_pair2.

Ltac inj_event_pair :=
  match goal with
  | [H : existT _ _ _ = existT _ _ _ |- _] => (apply (Eqdep.EqdepTheory.inj_pair2 Type) in H; subst)
  end.

Ltac clear_id :=
  match goal with
  | [H : ?a = ?a |- _] => clear H
  end.

Ltac auto_is_trace := repeat (try (unfold observe; cbn; try constructor)).
Ltac inj_event_pair_all := repeat (try inj_event_pair; idtac).
Ltac auto_is_trace_H H := unfold observe in H; cbn in H.
Ltac inv_is_trace H := auto_is_trace_H H; inversion H; try inj_event_pair_all; try clear_id; try clear H.

Ltac auto_inv_is_trace :=
  match goal with
  | H: is_traceF _ _ |- _ => inv_is_trace H
  end.

Require Import Omega.

Ltac inv_output :=
  match goal with
  | H: OutputS _ = OutputS _ |- _ => inversion H; try auto; try omega
  end.

Lemma safe_inductive_invariant : forall (s s': StateT) (a: ActionT), is_trace safe_env (ret_rl_trace (s, a, s')) -> s <= 3 -> s' <= 3.
Proof.
  cbn.
  unfold is_trace, safe_env.
  intros.
  destruct (Nat.eqb_spec s 3).
  - subst. clear H0.
    destruct a; repeat (auto_inv_is_trace; try inv_output).
  - assert (s < 3) by omega. clear H0. clear n.
    destruct s.
    + destruct a; repeat (auto_inv_is_trace; try inv_output).
    + destruct s.
      * destruct a; repeat (auto_inv_is_trace; try inv_output).
      * destruct s. destruct a; repeat (auto_inv_is_trace; try inv_output). omega.
Qed.

(* We can say, if an agent start form position less equal than 3, and the environment satisfies the inductive invariant, the trace of environment will not reach the position 4. *)

Inductive trace_init : (StateT -> Prop) -> @trace rlE unit -> Prop :=
| ret_trace_init :
    forall (s s': StateT) (a: ActionT) (phi: StateT -> Prop),
      phi s -> trace_init phi (ret_rl_trace (s, a, s'))
| bind_trace_init :
    forall (s s': StateT) (a: ActionT) (phi: StateT -> Prop) tr,
      phi s -> trace_init phi (bind_rl_trace (s, a, s') tr).

Inductive trace_end : (StateT -> Prop) -> @trace rlE unit -> Prop :=
| ret_trace_end :
    forall (s s': StateT) (a: ActionT) (phi: StateT -> Prop),
      phi s' -> trace_end phi (ret_rl_trace (s, a, s'))
| bind_trace_end :
    forall (s s': StateT) (a: ActionT) (phi: StateT -> Prop) tr,
      trace_end phi tr -> trace_end phi (bind_rl_trace (s, a, s') tr).

(* if "[InputS s] [InputA a] [OutputS s', tt] tr is" a trace of an environment, then *)
(*   1. tr is a trace of this environment. *)
(*   2. "[InputS s] [InputA a] [<OutputS s'>]" is a trace of this environment. *)
(* This lemma requirs the rl environment to has to gerantee the following rule: *)
(*   1) read a state, i.e. "s". *)
(*   2) read a action from agent, i.e. "a". *)
(*   3) run a pure function "f: StateT -> ActionT -> StateT" on the read state and action, i.e. "s' <- f s a". *)
(*   4) rewrite the new state, i.e. "s'". *)
(*   5) go back to step 1. *)

Definition env_generator (f: StateT -> ActionT -> StateT) : itree rlE unit :=
  (rec-fix env_ _ :=
     state <- trigger_inr1 InputS ;; (* read current state *)
           action <- trigger_inr1 InputA ;; (* read action from agent *)
           trigger_inr1 (OutputS (f state action)) ;; (* write new state *)
           env_ tt
  ) tt.

Lemma is_trace_rl_split: forall s a s' tr,
    is_rltrace tr ->
    is_trace safe_env (bind_rl_trace (s, a, s') tr) ->
    (is_trace safe_env tr) /\ is_trace safe_env (ret_rl_trace (s, a, s')).
Proof.
  intros. cbn in H0. unfold safe_env, is_trace in H0.
  destruct s.
  - destruct a.
    do 5 auto_inv_is_trace. split.
    cbn in H4.
    unfold safe_env. unfold rec_fix. unfold rec.
    match goal with
    | H : is_traceF (TauF (interp_mrec (calling' ?a) _)) _ |- _ => remember a as callf
    end.
    match goal with
    | _ : _ |- is_trace (mrec (calling' ?b) _) _ => remember b as callf'
    end.
Admitted.

(* The following safe lemma can be proved by the inductive invariant. *)

Lemma safe_inductive_invariant_one_case : forall s s', is_trace safe_env (ret_rl_trace (s, Right, s')) -> s < 3 -> s' <= 3.
Proof.
  unfold is_trace, safe_env.
  intros.
  destruct s.
  - clear H0. repeat (auto_inv_is_trace; try inv_output).
  - destruct s.
    + repeat (auto_inv_is_trace; try inv_output).
    + destruct s.
      * repeat (auto_inv_is_trace; try inv_output).
      * omega.
Qed.

Lemma safe: forall (tr: @trace rlE unit),
    is_rltrace tr ->
    trace_init (fun s => s <= 3) tr ->
    trace_end (fun s' => s' = 4) tr ->
    not (is_trace safe_env tr).
Proof.
  intros.
  inversion H0; inversion H1; subst.
  - inv_is_trace H7.
    unfold not; intros.
    apply safe_inductive_invariant in H3; auto. omega.
  - inversion H7.
  - inversion H7.
  - inv_is_trace H7. unfold not. intros.
    induction H.
    + destruct x, p. inv_is_trace H0. inv_is_trace H1.
      apply safe_inductive_invariant in H3; auto. omega.
    + destruct x1, x2, p, p0. inversion H. subst.
      inv_is_trace H0. inv_is_trace H1. inv_is_trace H6.
      apply is_trace_rl_split in H3.
      destruct H3.
      apply safe_inductive_invariant in H0; auto. omega.
      apply safe_inductive_invariant in H1; auto. constructor.
    + destruct x1, x2, p, p0. inversion H. subst.
      apply IHis_rltrace; clear IHis_rltrace. 
      * constructor. inv_is_trace H1. inv_is_trace H8. auto.
      * constructor. inv_is_trace H0.
        apply is_trace_rl_split in H3.
        destruct H3. apply safe_inductive_invariant in H3; auto. apply H4.
      * inv_is_trace H0.
        apply is_trace_rl_split in H3.
        destruct H3; auto. apply H4.
Qed.